/**
 * @file test_timer_enum_operators.cc
 * @brief Unit tests for enum stream operators
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <doctest/doctest.h>
#include <../include/sdlpp/core/time.hh>
#include <sstream>
#include <string>

TEST_SUITE("timer_enum_operators") {

    TEST_CASE("day_of_week stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::day_of_week::sunday;
            CHECK(oss.str() == "sunday");
            oss.str("");
            oss << sdlpp::day_of_week::monday;
            CHECK(oss.str() == "monday");
            oss.str("");
            oss << sdlpp::day_of_week::tuesday;
            CHECK(oss.str() == "tuesday");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::day_of_week value;
            iss.str("sunday");
            iss >> value;
            CHECK(value == sdlpp::day_of_week::sunday);
            iss.clear();
            iss.str("monday");
            iss >> value;
            CHECK(value == sdlpp::day_of_week::monday);
            iss.clear();
            iss.str("tuesday");
            iss >> value;
            CHECK(value == sdlpp::day_of_week::tuesday);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::day_of_week original = sdlpp::day_of_week::sunday;
            sdlpp::day_of_week result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }

    TEST_CASE("date_format stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::date_format::yyyy_mm_dd;
            CHECK(oss.str() == "yyyy_mm_dd");
            oss.str("");
            oss << sdlpp::date_format::dd_mm_yyyy;
            CHECK(oss.str() == "dd_mm_yyyy");
            oss.str("");
            oss << sdlpp::date_format::mm_dd_yyyy;
            CHECK(oss.str() == "mm_dd_yyyy");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::date_format value;
            iss.str("yyyy_mm_dd");
            iss >> value;
            CHECK(value == sdlpp::date_format::yyyy_mm_dd);
            iss.clear();
            iss.str("dd_mm_yyyy");
            iss >> value;
            CHECK(value == sdlpp::date_format::dd_mm_yyyy);
            iss.clear();
            iss.str("mm_dd_yyyy");
            iss >> value;
            CHECK(value == sdlpp::date_format::mm_dd_yyyy);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::date_format original = sdlpp::date_format::yyyy_mm_dd;
            sdlpp::date_format result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }

    TEST_CASE("time_format stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::time_format::hour_24;
            CHECK(oss.str() == "hour_24");
            oss.str("");
            oss << sdlpp::time_format::hour_12;
            CHECK(oss.str() == "hour_12");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::time_format value;
            iss.str("hour_24");
            iss >> value;
            CHECK(value == sdlpp::time_format::hour_24);
            iss.clear();
            iss.str("hour_12");
            iss >> value;
            CHECK(value == sdlpp::time_format::hour_12);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::time_format original = sdlpp::time_format::hour_24;
            sdlpp::time_format result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }
}