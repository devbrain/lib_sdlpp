/**
 * @file test_config_enum_operators.cc
 * @brief Unit tests for enum stream operators
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <doctest/doctest.h>
#include <../include/sdlpp/core/log.hh>
#include <sstream>
#include <string>

TEST_SUITE("config_enum_operators") {

    TEST_CASE("log_priority stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::log_priority::invalid;
            CHECK(oss.str() == "invalid");
            oss.str("");
            oss << sdlpp::log_priority::trace;
            CHECK(oss.str() == "trace");
            oss.str("");
            oss << sdlpp::log_priority::verbose;
            CHECK(oss.str() == "verbose");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::log_priority value;
            iss.str("invalid");
            iss >> value;
            CHECK(value == sdlpp::log_priority::invalid);
            iss.clear();
            iss.str("trace");
            iss >> value;
            CHECK(value == sdlpp::log_priority::trace);
            iss.clear();
            iss.str("verbose");
            iss >> value;
            CHECK(value == sdlpp::log_priority::verbose);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::log_priority original = sdlpp::log_priority::invalid;
            sdlpp::log_priority result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }

    TEST_CASE("log_category stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::log_category::application;
            CHECK(oss.str() == "application");
            oss.str("");
            oss << sdlpp::log_category::error;
            CHECK(oss.str() == "error");
            oss.str("");
            oss << sdlpp::log_category::assert;
            CHECK(oss.str() == "assert");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::log_category value;
            iss.str("application");
            iss >> value;
            CHECK(value == sdlpp::log_category::application);
            iss.clear();
            iss.str("error");
            iss >> value;
            CHECK(value == sdlpp::log_category::error);
            iss.clear();
            iss.str("assert");
            iss >> value;
            CHECK(value == sdlpp::log_category::assert);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::log_category original = sdlpp::log_category::application;
            sdlpp::log_category result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }
}