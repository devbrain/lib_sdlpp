/**
 * @file test_filesystem_enum_operators.cc
 * @brief Unit tests for enum stream operators
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <doctest/doctest.h>
#include <sdlpp/io/iostream.hh>
#include <sstream>
#include <string>

TEST_SUITE("filesystem_enum_operators") {

    TEST_CASE("io_seek_pos stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::io_seek_pos::set;
            CHECK(oss.str() == "set");
            oss.str("");
            oss << sdlpp::io_seek_pos::current;
            CHECK(oss.str() == "current");
            oss.str("");
            oss << sdlpp::io_seek_pos::end;
            CHECK(oss.str() == "end");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::io_seek_pos value;
            iss.str("set");
            iss >> value;
            CHECK(value == sdlpp::io_seek_pos::set);
            iss.clear();
            iss.str("current");
            iss >> value;
            CHECK(value == sdlpp::io_seek_pos::current);
            iss.clear();
            iss.str("end");
            iss >> value;
            CHECK(value == sdlpp::io_seek_pos::end);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::io_seek_pos original = sdlpp::io_seek_pos::set;
            sdlpp::io_seek_pos result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }

    TEST_CASE("io_status stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::io_status::ready;
            CHECK(oss.str() == "ready");
            oss.str("");
            oss << sdlpp::io_status::error;
            CHECK(oss.str() == "error");
            oss.str("");
            oss << sdlpp::io_status::eof;
            CHECK(oss.str() == "eof");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::io_status value;
            iss.str("ready");
            iss >> value;
            CHECK(value == sdlpp::io_status::ready);
            iss.clear();
            iss.str("error");
            iss >> value;
            CHECK(value == sdlpp::io_status::error);
            iss.clear();
            iss.str("eof");
            iss >> value;
            CHECK(value == sdlpp::io_status::eof);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::io_status original = sdlpp::io_status::ready;
            sdlpp::io_status result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }
}