/**
 * @file test_events_enum_operators.cc
 * @brief Unit tests for enum stream operators
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <doctest/doctest.h>
#include <sdlpp/events/mouse_codes.hh>
#include <sstream>
#include <string>

TEST_SUITE("events_enum_operators") {

    TEST_CASE("mouse_button stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::mouse_button::left;
            CHECK(oss.str() == "left");
            oss.str("");
            oss << sdlpp::mouse_button::middle;
            CHECK(oss.str() == "middle");
            oss.str("");
            oss << sdlpp::mouse_button::right;
            CHECK(oss.str() == "right");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::mouse_button value;
            iss.str("left");
            iss >> value;
            CHECK(value == sdlpp::mouse_button::left);
            iss.clear();
            iss.str("middle");
            iss >> value;
            CHECK(value == sdlpp::mouse_button::middle);
            iss.clear();
            iss.str("right");
            iss >> value;
            CHECK(value == sdlpp::mouse_button::right);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::mouse_button original = sdlpp::mouse_button::left;
            sdlpp::mouse_button result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }

    TEST_CASE("mouse_button_mask stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << static_cast<sdlpp::mouse_button_mask>(0);
            CHECK(oss.str() == "none");
            oss.str("");
            oss << std::hex << static_cast<sdlpp::mouse_button_mask>(0x5) << std::dec;
            CHECK(oss.str() == "5");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::mouse_button_mask value;
            iss.str("left");
            iss >> value;
            CHECK(value == sdlpp::mouse_button_mask::left);
            iss.clear();
            iss.str("middle");
            iss >> value;
            CHECK(value == sdlpp::mouse_button_mask::middle);
            iss.clear();

            // Test parsing multiple flags
            iss.str("left | middle");
            iss >> value;
            CHECK((static_cast<unsigned int>(value) & static_cast<unsigned int>(sdlpp::mouse_button_mask::left)) != 0);
            CHECK((static_cast<unsigned int>(value) & static_cast<unsigned int>(sdlpp::mouse_button_mask::middle)) != 0);
            iss.clear();

            // Test hex parsing with 0x prefix
            iss.str("0xFF");
            iss >> value;
            CHECK(static_cast<unsigned int>(value) == 0xFF);
            iss.clear();

            // Test hex parsing with stream flag
            iss.str("FF");
            iss >> std::hex >> value >> std::dec;
            CHECK(static_cast<unsigned int>(value) == 0xFF);
        }

        SUBCASE("round-trip conversion works") {
            // Flags enum - test with multiple flags
            std::stringstream ss;
            sdlpp::mouse_button_mask original = static_cast<sdlpp::mouse_button_mask>(
                static_cast<unsigned int>(sdlpp::mouse_button_mask::left) |
                static_cast<unsigned int>(sdlpp::mouse_button_mask::middle)
            );


            // Output will be human-readable flag names
            ss << original;
            std::string output = ss.str();
            CHECK(output.find("left") != std::string::npos);
            CHECK(output.find("middle") != std::string::npos);
            CHECK(output.find(" | ") != std::string::npos);
        }
    }

    TEST_CASE("mouse_wheel_direction stream operators") {
        SUBCASE("operator<< outputs correct string representation") {
            std::ostringstream oss;
            oss << sdlpp::mouse_wheel_direction::normal;
            CHECK(oss.str() == "normal");
            oss.str("");
            oss << sdlpp::mouse_wheel_direction::flipped;
            CHECK(oss.str() == "flipped");
            oss.str("");
        }

        SUBCASE("operator>> parses string correctly") {
            std::istringstream iss;
            sdlpp::mouse_wheel_direction value;
            iss.str("normal");
            iss >> value;
            CHECK(value == sdlpp::mouse_wheel_direction::normal);
            iss.clear();
            iss.str("flipped");
            iss >> value;
            CHECK(value == sdlpp::mouse_wheel_direction::flipped);
            iss.clear();

            // Test integer parsing
            iss.str("0");
            iss >> value;
            CHECK(static_cast<int>(value) == 0);
        }

        SUBCASE("round-trip conversion works") {
            std::stringstream ss;
            sdlpp::mouse_wheel_direction original = sdlpp::mouse_wheel_direction::normal;
            sdlpp::mouse_wheel_direction result;

            ss << original;
            ss >> result;

            CHECK(result == original);
        }
    }
}