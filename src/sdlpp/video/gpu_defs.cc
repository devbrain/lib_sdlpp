/**
 * @file gpu_defs.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/video/gpu_defs.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
#include <vector>

namespace sdlpp::gpu {
    std::ostream& operator<<(std::ostream& os, primitive_type value) {
        switch (value) {
            case primitive_type::triangle_list:
                return os << "triangle_list";
            case primitive_type::triangle_strip:
                return os << "triangle_strip";
            case primitive_type::line_list:
                return os << "line_list";
            case primitive_type::line_strip:
                return os << "line_strip";
            case primitive_type::point_list:
                return os << "point_list";
            default:
                return os << "Unknown_primitive_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, primitive_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <primitive_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "triangle_list") {
            value = primitive_type::triangle_list;
        } else if (str == "triangle_strip") {
            value = primitive_type::triangle_strip;
        } else if (str == "line_list") {
            value = primitive_type::line_list;
        } else if (str == "line_strip") {
            value = primitive_type::line_strip;
        } else if (str == "point_list") {
            value = primitive_type::point_list;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <primitive_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, load_op value) {
        switch (value) {
            case load_op::load:
                return os << "load";
            case load_op::clear:
                return os << "clear";
            case load_op::dont_care:
                return os << "dont_care";
            default:
                return os << "Unknown_load_op(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, load_op& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <load_op>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "load") {
            value = load_op::load;
        } else if (str == "clear") {
            value = load_op::clear;
        } else if (str == "dont_care") {
            value = load_op::dont_care;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <load_op>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, store_op value) {
        switch (value) {
            case store_op::store:
                return os << "store";
            case store_op::dont_care:
                return os << "dont_care";
            case store_op::resolve:
                return os << "resolve";
            case store_op::resolve_and_store:
                return os << "resolve_and_store";
            default:
                return os << "Unknown_store_op(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, store_op& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <store_op>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "store") {
            value = store_op::store;
        } else if (str == "dont_care") {
            value = store_op::dont_care;
        } else if (str == "resolve") {
            value = store_op::resolve;
        } else if (str == "resolve_and_store") {
            value = store_op::resolve_and_store;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <store_op>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, index_element_size value) {
        switch (value) {
            case index_element_size::uint16:
                return os << "uint16";
            case index_element_size::uint32:
                return os << "uint32";
            default:
                return os << "Unknown_index_element_size(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, index_element_size& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <index_element_size>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "uint16") {
            value = index_element_size::uint16;
        } else if (str == "uint32") {
            value = index_element_size::uint32;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <index_element_size>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, texture_format value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::invalid)) != 0) {
            active_flags.emplace_back("invalid");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::a8_unorm)) != 0) {
            active_flags.emplace_back("a8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8_unorm)) != 0) {
            active_flags.emplace_back("r8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8_unorm)) != 0) {
            active_flags.emplace_back("r8g8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8b8a8_unorm)) != 0) {
            active_flags.emplace_back("r8g8b8a8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16_unorm)) != 0) {
            active_flags.emplace_back("r16_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16_unorm)) != 0) {
            active_flags.emplace_back("r16g16_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16b16a16_unorm)) != 0) {
            active_flags.emplace_back("r16g16b16a16_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r10g10b10a2_unorm)) != 0) {
            active_flags.emplace_back("r10g10b10a2_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::b5g6r5_unorm)) != 0) {
            active_flags.emplace_back("b5g6r5_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::b5g5r5a1_unorm)) != 0) {
            active_flags.emplace_back("b5g5r5a1_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::b4g4r4a4_unorm)) != 0) {
            active_flags.emplace_back("b4g4r4a4_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::b8g8r8a8_unorm)) != 0) {
            active_flags.emplace_back("b8g8r8a8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc1_rgba_unorm)) != 0) {
            active_flags.emplace_back("bc1_rgba_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc2_rgba_unorm)) != 0) {
            active_flags.emplace_back("bc2_rgba_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc3_rgba_unorm)) != 0) {
            active_flags.emplace_back("bc3_rgba_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc4_r_unorm)) != 0) {
            active_flags.emplace_back("bc4_r_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc5_rg_unorm)) != 0) {
            active_flags.emplace_back("bc5_rg_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc7_rgba_unorm)) != 0) {
            active_flags.emplace_back("bc7_rgba_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8_snorm)) != 0) {
            active_flags.emplace_back("r8_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8_snorm)) != 0) {
            active_flags.emplace_back("r8g8_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8b8a8_snorm)) != 0) {
            active_flags.emplace_back("r8g8b8a8_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16_snorm)) != 0) {
            active_flags.emplace_back("r16_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16_snorm)) != 0) {
            active_flags.emplace_back("r16g16_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16b16a16_snorm)) != 0) {
            active_flags.emplace_back("r16g16b16a16_snorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8_uint)) != 0) {
            active_flags.emplace_back("r8_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8_uint)) != 0) {
            active_flags.emplace_back("r8g8_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8b8a8_uint)) != 0) {
            active_flags.emplace_back("r8g8b8a8_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16_uint)) != 0) {
            active_flags.emplace_back("r16_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16_uint)) != 0) {
            active_flags.emplace_back("r16g16_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16b16a16_uint)) != 0) {
            active_flags.emplace_back("r16g16b16a16_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32_uint)) != 0) {
            active_flags.emplace_back("r32_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32_uint)) != 0) {
            active_flags.emplace_back("r32g32_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32b32a32_uint)) != 0) {
            active_flags.emplace_back("r32g32b32a32_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8_int)) != 0) {
            active_flags.emplace_back("r8_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8_int)) != 0) {
            active_flags.emplace_back("r8g8_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8b8a8_int)) != 0) {
            active_flags.emplace_back("r8g8b8a8_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16_int)) != 0) {
            active_flags.emplace_back("r16_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16_int)) != 0) {
            active_flags.emplace_back("r16g16_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16b16a16_int)) != 0) {
            active_flags.emplace_back("r16g16b16a16_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32_int)) != 0) {
            active_flags.emplace_back("r32_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32_int)) != 0) {
            active_flags.emplace_back("r32g32_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32b32a32_int)) != 0) {
            active_flags.emplace_back("r32g32b32a32_int");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16_float)) != 0) {
            active_flags.emplace_back("r16_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16_float)) != 0) {
            active_flags.emplace_back("r16g16_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r16g16b16a16_float)) != 0) {
            active_flags.emplace_back("r16g16b16a16_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32_float)) != 0) {
            active_flags.emplace_back("r32_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32_float)) != 0) {
            active_flags.emplace_back("r32g32_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r32g32b32a32_float)) != 0) {
            active_flags.emplace_back("r32g32b32a32_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r11g11b10_ufloat)) != 0) {
            active_flags.emplace_back("r11g11b10_ufloat");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::r8g8b8a8_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("r8g8b8a8_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::b8g8r8a8_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("b8g8r8a8_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc1_rgba_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("bc1_rgba_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc2_rgba_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("bc2_rgba_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc3_rgba_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("bc3_rgba_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::bc7_rgba_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("bc7_rgba_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::d16_unorm)) != 0) {
            active_flags.emplace_back("d16_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::d24_unorm)) != 0) {
            active_flags.emplace_back("d24_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::d32_float)) != 0) {
            active_flags.emplace_back("d32_float");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::d24_unorm_s8_uint)) != 0) {
            active_flags.emplace_back("d24_unorm_s8_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::d32_float_s8_uint)) != 0) {
            active_flags.emplace_back("d32_float_s8_uint");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_4x4_unorm)) != 0) {
            active_flags.emplace_back("astc_4x4_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_5x4_unorm)) != 0) {
            active_flags.emplace_back("astc_5x4_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_5x5_unorm)) != 0) {
            active_flags.emplace_back("astc_5x5_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_6x5_unorm)) != 0) {
            active_flags.emplace_back("astc_6x5_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_6x6_unorm)) != 0) {
            active_flags.emplace_back("astc_6x6_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x5_unorm)) != 0) {
            active_flags.emplace_back("astc_8x5_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x6_unorm)) != 0) {
            active_flags.emplace_back("astc_8x6_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x8_unorm)) != 0) {
            active_flags.emplace_back("astc_8x8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x5_unorm)) != 0) {
            active_flags.emplace_back("astc_10x5_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x6_unorm)) != 0) {
            active_flags.emplace_back("astc_10x6_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x8_unorm)) != 0) {
            active_flags.emplace_back("astc_10x8_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x10_unorm)) != 0) {
            active_flags.emplace_back("astc_10x10_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_12x10_unorm)) != 0) {
            active_flags.emplace_back("astc_12x10_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_12x12_unorm)) != 0) {
            active_flags.emplace_back("astc_12x12_unorm");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_4x4_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_4x4_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_5x4_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_5x4_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_5x5_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_5x5_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_6x5_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_6x5_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_6x6_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_6x6_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x5_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_8x5_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x6_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_8x6_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_8x8_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_8x8_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x5_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_10x5_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x6_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_10x6_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x8_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_10x8_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_10x10_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_10x10_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_12x10_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_12x10_unorm_srgb");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_format::astc_12x12_unorm_srgb)) !=
            0) {
            active_flags.emplace_back("astc_12x12_unorm_srgb");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, texture_format& value) {
        std::string str;
        is >> str;

        value = static_cast <texture_format>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <texture_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <texture_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "invalid") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::invalid));
                found = true;
            }
            if (flag_name == "a8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::a8_unorm));
                found = true;
            }
            if (flag_name == "r8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8_unorm));
                found = true;
            }
            if (flag_name == "r8g8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8_unorm));
                found = true;
            }
            if (flag_name == "r8g8b8a8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8b8a8_unorm));
                found = true;
            }
            if (flag_name == "r16_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16_unorm));
                found = true;
            }
            if (flag_name == "r16g16_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16_unorm));
                found = true;
            }
            if (flag_name == "r16g16b16a16_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16b16a16_unorm));
                found = true;
            }
            if (flag_name == "r10g10b10a2_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r10g10b10a2_unorm));
                found = true;
            }
            if (flag_name == "b5g6r5_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::b5g6r5_unorm));
                found = true;
            }
            if (flag_name == "b5g5r5a1_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::b5g5r5a1_unorm));
                found = true;
            }
            if (flag_name == "b4g4r4a4_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::b4g4r4a4_unorm));
                found = true;
            }
            if (flag_name == "b8g8r8a8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::b8g8r8a8_unorm));
                found = true;
            }
            if (flag_name == "bc1_rgba_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc1_rgba_unorm));
                found = true;
            }
            if (flag_name == "bc2_rgba_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc2_rgba_unorm));
                found = true;
            }
            if (flag_name == "bc3_rgba_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc3_rgba_unorm));
                found = true;
            }
            if (flag_name == "bc4_r_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc4_r_unorm));
                found = true;
            }
            if (flag_name == "bc5_rg_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc5_rg_unorm));
                found = true;
            }
            if (flag_name == "bc7_rgba_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::bc7_rgba_unorm));
                found = true;
            }
            if (flag_name == "r8_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8_snorm));
                found = true;
            }
            if (flag_name == "r8g8_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8_snorm));
                found = true;
            }
            if (flag_name == "r8g8b8a8_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8b8a8_snorm));
                found = true;
            }
            if (flag_name == "r16_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16_snorm));
                found = true;
            }
            if (flag_name == "r16g16_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16_snorm));
                found = true;
            }
            if (flag_name == "r16g16b16a16_snorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16b16a16_snorm));
                found = true;
            }
            if (flag_name == "r8_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8_uint));
                found = true;
            }
            if (flag_name == "r8g8_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8_uint));
                found = true;
            }
            if (flag_name == "r8g8b8a8_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8b8a8_uint));
                found = true;
            }
            if (flag_name == "r16_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16_uint));
                found = true;
            }
            if (flag_name == "r16g16_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16_uint));
                found = true;
            }
            if (flag_name == "r16g16b16a16_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16b16a16_uint));
                found = true;
            }
            if (flag_name == "r32_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32_uint));
                found = true;
            }
            if (flag_name == "r32g32_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32_uint));
                found = true;
            }
            if (flag_name == "r32g32b32a32_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32b32a32_uint));
                found = true;
            }
            if (flag_name == "r8_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8_int));
                found = true;
            }
            if (flag_name == "r8g8_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8_int));
                found = true;
            }
            if (flag_name == "r8g8b8a8_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r8g8b8a8_int));
                found = true;
            }
            if (flag_name == "r16_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16_int));
                found = true;
            }
            if (flag_name == "r16g16_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16_int));
                found = true;
            }
            if (flag_name == "r16g16b16a16_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16b16a16_int));
                found = true;
            }
            if (flag_name == "r32_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32_int));
                found = true;
            }
            if (flag_name == "r32g32_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32_int));
                found = true;
            }
            if (flag_name == "r32g32b32a32_int") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32b32a32_int));
                found = true;
            }
            if (flag_name == "r16_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16_float));
                found = true;
            }
            if (flag_name == "r16g16_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16_float));
                found = true;
            }
            if (flag_name == "r16g16b16a16_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r16g16b16a16_float));
                found = true;
            }
            if (flag_name == "r32_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32_float));
                found = true;
            }
            if (flag_name == "r32g32_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32_float));
                found = true;
            }
            if (flag_name == "r32g32b32a32_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r32g32b32a32_float));
                found = true;
            }
            if (flag_name == "r11g11b10_ufloat") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::r11g11b10_ufloat));
                found = true;
            }
            if (flag_name == "r8g8b8a8_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::r8g8b8a8_unorm_srgb));
                found = true;
            }
            if (flag_name == "b8g8r8a8_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::b8g8r8a8_unorm_srgb));
                found = true;
            }
            if (flag_name == "bc1_rgba_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::bc1_rgba_unorm_srgb));
                found = true;
            }
            if (flag_name == "bc2_rgba_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::bc2_rgba_unorm_srgb));
                found = true;
            }
            if (flag_name == "bc3_rgba_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::bc3_rgba_unorm_srgb));
                found = true;
            }
            if (flag_name == "bc7_rgba_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::bc7_rgba_unorm_srgb));
                found = true;
            }
            if (flag_name == "d16_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::d16_unorm));
                found = true;
            }
            if (flag_name == "d24_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::d24_unorm));
                found = true;
            }
            if (flag_name == "d32_float") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::d32_float));
                found = true;
            }
            if (flag_name == "d24_unorm_s8_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::d24_unorm_s8_uint));
                found = true;
            }
            if (flag_name == "d32_float_s8_uint") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::d32_float_s8_uint));
                found = true;
            }
            if (flag_name == "astc_4x4_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_4x4_unorm));
                found = true;
            }
            if (flag_name == "astc_5x4_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_5x4_unorm));
                found = true;
            }
            if (flag_name == "astc_5x5_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_5x5_unorm));
                found = true;
            }
            if (flag_name == "astc_6x5_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_6x5_unorm));
                found = true;
            }
            if (flag_name == "astc_6x6_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_6x6_unorm));
                found = true;
            }
            if (flag_name == "astc_8x5_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_8x5_unorm));
                found = true;
            }
            if (flag_name == "astc_8x6_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_8x6_unorm));
                found = true;
            }
            if (flag_name == "astc_8x8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_8x8_unorm));
                found = true;
            }
            if (flag_name == "astc_10x5_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_10x5_unorm));
                found = true;
            }
            if (flag_name == "astc_10x6_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_10x6_unorm));
                found = true;
            }
            if (flag_name == "astc_10x8_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_10x8_unorm));
                found = true;
            }
            if (flag_name == "astc_10x10_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_10x10_unorm));
                found = true;
            }
            if (flag_name == "astc_12x10_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_12x10_unorm));
                found = true;
            }
            if (flag_name == "astc_12x12_unorm") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_format::astc_12x12_unorm));
                found = true;
            }
            if (flag_name == "astc_4x4_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_4x4_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_5x4_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_5x4_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_5x5_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_5x5_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_6x5_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_6x5_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_6x6_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_6x6_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_8x5_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_8x5_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_8x6_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_8x6_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_8x8_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_8x8_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_10x5_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_10x5_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_10x6_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_10x6_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_10x8_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_10x8_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_10x10_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_10x10_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_12x10_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_12x10_unorm_srgb));
                found = true;
            }
            if (flag_name == "astc_12x12_unorm_srgb") {
                value = static_cast <texture_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_format::astc_12x12_unorm_srgb));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <texture_format>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, texture_type value) {
        switch (value) {
            case texture_type::texture_2d:
                return os << "texture_2d";
            case texture_type::texture_2d_array:
                return os << "texture_2d_array";
            case texture_type::texture_3d:
                return os << "texture_3d";
            case texture_type::cube:
                return os << "cube";
            case texture_type::cube_array:
                return os << "cube_array";
            default:
                return os << "Unknown_texture_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, texture_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <texture_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "texture_2d") {
            value = texture_type::texture_2d;
        } else if (str == "texture_2d_array") {
            value = texture_type::texture_2d_array;
        } else if (str == "texture_3d") {
            value = texture_type::texture_3d;
        } else if (str == "cube") {
            value = texture_type::cube;
        } else if (str == "cube_array") {
            value = texture_type::cube_array;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <texture_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, sample_count value) {
        switch (value) {
            case sample_count::count_1:
                return os << "count_1";
            case sample_count::count_2:
                return os << "count_2";
            case sample_count::count_4:
                return os << "count_4";
            case sample_count::count_8:
                return os << "count_8";
            default:
                return os << "Unknown_sample_count(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, sample_count& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <sample_count>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "count_1") {
            value = sample_count::count_1;
        } else if (str == "count_2") {
            value = sample_count::count_2;
        } else if (str == "count_4") {
            value = sample_count::count_4;
        } else if (str == "count_8") {
            value = sample_count::count_8;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <sample_count>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, cube_map_face value) {
        switch (value) {
            case cube_map_face::positive_x:
                return os << "positive_x";
            case cube_map_face::negative_x:
                return os << "negative_x";
            case cube_map_face::positive_y:
                return os << "positive_y";
            case cube_map_face::negative_y:
                return os << "negative_y";
            case cube_map_face::positive_z:
                return os << "positive_z";
            case cube_map_face::negative_z:
                return os << "negative_z";
            default:
                return os << "Unknown_cube_map_face(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, cube_map_face& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <cube_map_face>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "positive_x") {
            value = cube_map_face::positive_x;
        } else if (str == "negative_x") {
            value = cube_map_face::negative_x;
        } else if (str == "positive_y") {
            value = cube_map_face::positive_y;
        } else if (str == "negative_y") {
            value = cube_map_face::negative_y;
        } else if (str == "positive_z") {
            value = cube_map_face::positive_z;
        } else if (str == "negative_z") {
            value = cube_map_face::negative_z;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <cube_map_face>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, transfer_buffer_usage value) {
        switch (value) {
            case transfer_buffer_usage::upload:
                return os << "upload";
            case transfer_buffer_usage::download:
                return os << "download";
            default:
                return os << "Unknown_transfer_buffer_usage(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, transfer_buffer_usage& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <transfer_buffer_usage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "upload") {
            value = transfer_buffer_usage::upload;
        } else if (str == "download") {
            value = transfer_buffer_usage::download;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <transfer_buffer_usage>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, shader_stage value) {
        switch (value) {
            case shader_stage::vertex:
                return os << "vertex";
            case shader_stage::fragment:
                return os << "fragment";
            default:
                return os << "Unknown_shader_stage(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, shader_stage& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <shader_stage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "vertex") {
            value = shader_stage::vertex;
        } else if (str == "fragment") {
            value = shader_stage::fragment;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <shader_stage>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, shader_format value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::invalid)) != 0) {
            active_flags.emplace_back("invalid");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::spirv)) != 0) {
            active_flags.emplace_back("spirv");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::dxbc)) != 0) {
            active_flags.emplace_back("dxbc");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::dxil)) != 0) {
            active_flags.emplace_back("dxil");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::msl)) != 0) {
            active_flags.emplace_back("msl");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(shader_format::metallib)) != 0) {
            active_flags.emplace_back("metallib");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, shader_format& value) {
        std::string str;
        is >> str;

        value = static_cast <shader_format>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <shader_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <shader_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "invalid") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::invalid));
                found = true;
            }
            if (flag_name == "spirv") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::spirv));
                found = true;
            }
            if (flag_name == "dxbc") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::dxbc));
                found = true;
            }
            if (flag_name == "dxil") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::dxil));
                found = true;
            }
            if (flag_name == "msl") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::msl));
                found = true;
            }
            if (flag_name == "metallib") {
                value = static_cast <shader_format>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(shader_format::metallib));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <shader_format>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, vertex_element_format value) {
        switch (value) {
            case vertex_element_format::invalid:
                return os << "invalid";
            case vertex_element_format::int1:
                return os << "int1";
            case vertex_element_format::int2:
                return os << "int2";
            case vertex_element_format::int3:
                return os << "int3";
            case vertex_element_format::int4:
                return os << "int4";
            case vertex_element_format::uint1:
                return os << "uint1";
            case vertex_element_format::uint2:
                return os << "uint2";
            case vertex_element_format::uint3:
                return os << "uint3";
            case vertex_element_format::uint4:
                return os << "uint4";
            case vertex_element_format::float1:
                return os << "float1";
            case vertex_element_format::float2:
                return os << "float2";
            case vertex_element_format::float3:
                return os << "float3";
            case vertex_element_format::float4:
                return os << "float4";
            case vertex_element_format::byte2:
                return os << "byte2";
            case vertex_element_format::byte4:
                return os << "byte4";
            case vertex_element_format::ubyte2:
                return os << "ubyte2";
            case vertex_element_format::ubyte4:
                return os << "ubyte4";
            case vertex_element_format::byte2_norm:
                return os << "byte2_norm";
            case vertex_element_format::byte4_norm:
                return os << "byte4_norm";
            case vertex_element_format::ubyte2_norm:
                return os << "ubyte2_norm";
            case vertex_element_format::ubyte4_norm:
                return os << "ubyte4_norm";
            case vertex_element_format::short2:
                return os << "short2";
            case vertex_element_format::short4:
                return os << "short4";
            case vertex_element_format::ushort2:
                return os << "ushort2";
            case vertex_element_format::ushort4:
                return os << "ushort4";
            case vertex_element_format::short2_norm:
                return os << "short2_norm";
            case vertex_element_format::short4_norm:
                return os << "short4_norm";
            case vertex_element_format::ushort2_norm:
                return os << "ushort2_norm";
            case vertex_element_format::ushort4_norm:
                return os << "ushort4_norm";
            case vertex_element_format::half2:
                return os << "half2";
            case vertex_element_format::half4:
                return os << "half4";
            default:
                return os << "Unknown_vertex_element_format(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, vertex_element_format& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <vertex_element_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = vertex_element_format::invalid;
        } else if (str == "int1") {
            value = vertex_element_format::int1;
        } else if (str == "int2") {
            value = vertex_element_format::int2;
        } else if (str == "int3") {
            value = vertex_element_format::int3;
        } else if (str == "int4") {
            value = vertex_element_format::int4;
        } else if (str == "uint1") {
            value = vertex_element_format::uint1;
        } else if (str == "uint2") {
            value = vertex_element_format::uint2;
        } else if (str == "uint3") {
            value = vertex_element_format::uint3;
        } else if (str == "uint4") {
            value = vertex_element_format::uint4;
        } else if (str == "float1") {
            value = vertex_element_format::float1;
        } else if (str == "float2") {
            value = vertex_element_format::float2;
        } else if (str == "float3") {
            value = vertex_element_format::float3;
        } else if (str == "float4") {
            value = vertex_element_format::float4;
        } else if (str == "byte2") {
            value = vertex_element_format::byte2;
        } else if (str == "byte4") {
            value = vertex_element_format::byte4;
        } else if (str == "ubyte2") {
            value = vertex_element_format::ubyte2;
        } else if (str == "ubyte4") {
            value = vertex_element_format::ubyte4;
        } else if (str == "byte2_norm") {
            value = vertex_element_format::byte2_norm;
        } else if (str == "byte4_norm") {
            value = vertex_element_format::byte4_norm;
        } else if (str == "ubyte2_norm") {
            value = vertex_element_format::ubyte2_norm;
        } else if (str == "ubyte4_norm") {
            value = vertex_element_format::ubyte4_norm;
        } else if (str == "short2") {
            value = vertex_element_format::short2;
        } else if (str == "short4") {
            value = vertex_element_format::short4;
        } else if (str == "ushort2") {
            value = vertex_element_format::ushort2;
        } else if (str == "ushort4") {
            value = vertex_element_format::ushort4;
        } else if (str == "short2_norm") {
            value = vertex_element_format::short2_norm;
        } else if (str == "short4_norm") {
            value = vertex_element_format::short4_norm;
        } else if (str == "ushort2_norm") {
            value = vertex_element_format::ushort2_norm;
        } else if (str == "ushort4_norm") {
            value = vertex_element_format::ushort4_norm;
        } else if (str == "half2") {
            value = vertex_element_format::half2;
        } else if (str == "half4") {
            value = vertex_element_format::half4;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <vertex_element_format>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, vertex_input_rate value) {
        switch (value) {
            case vertex_input_rate::vertex:
                return os << "vertex";
            case vertex_input_rate::instance:
                return os << "instance";
            default:
                return os << "Unknown_vertex_input_rate(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, vertex_input_rate& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <vertex_input_rate>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "vertex") {
            value = vertex_input_rate::vertex;
        } else if (str == "instance") {
            value = vertex_input_rate::instance;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <vertex_input_rate>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, fill_mode value) {
        switch (value) {
            case fill_mode::fill:
                return os << "fill";
            case fill_mode::line:
                return os << "line";
            default:
                return os << "Unknown_fill_mode(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, fill_mode& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <fill_mode>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "fill") {
            value = fill_mode::fill;
        } else if (str == "line") {
            value = fill_mode::line;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <fill_mode>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, cull_mode value) {
        switch (value) {
            case cull_mode::none:
                return os << "none";
            case cull_mode::front:
                return os << "front";
            case cull_mode::back:
                return os << "back";
            default:
                return os << "Unknown_cull_mode(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, cull_mode& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <cull_mode>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "none") {
            value = cull_mode::none;
        } else if (str == "front") {
            value = cull_mode::front;
        } else if (str == "back") {
            value = cull_mode::back;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <cull_mode>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, front_face value) {
        switch (value) {
            case front_face::counter_clockwise:
                return os << "counter_clockwise";
            case front_face::clockwise:
                return os << "clockwise";
            default:
                return os << "Unknown_front_face(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, front_face& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <front_face>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "counter_clockwise") {
            value = front_face::counter_clockwise;
        } else if (str == "clockwise") {
            value = front_face::clockwise;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <front_face>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, compare_op value) {
        switch (value) {
            case compare_op::invalid:
                return os << "invalid";
            case compare_op::never:
                return os << "never";
            case compare_op::less:
                return os << "less";
            case compare_op::equal:
                return os << "equal";
            case compare_op::less_or_equal:
                return os << "less_or_equal";
            case compare_op::greater:
                return os << "greater";
            case compare_op::not_equal:
                return os << "not_equal";
            case compare_op::greater_or_equal:
                return os << "greater_or_equal";
            case compare_op::always:
                return os << "always";
            default:
                return os << "Unknown_compare_op(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, compare_op& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <compare_op>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = compare_op::invalid;
        } else if (str == "never") {
            value = compare_op::never;
        } else if (str == "less") {
            value = compare_op::less;
        } else if (str == "equal") {
            value = compare_op::equal;
        } else if (str == "less_or_equal") {
            value = compare_op::less_or_equal;
        } else if (str == "greater") {
            value = compare_op::greater;
        } else if (str == "not_equal") {
            value = compare_op::not_equal;
        } else if (str == "greater_or_equal") {
            value = compare_op::greater_or_equal;
        } else if (str == "always") {
            value = compare_op::always;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <compare_op>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, stencil_op value) {
        switch (value) {
            case stencil_op::invalid:
                return os << "invalid";
            case stencil_op::keep:
                return os << "keep";
            case stencil_op::zero:
                return os << "zero";
            case stencil_op::replace:
                return os << "replace";
            case stencil_op::increment_and_clamp:
                return os << "increment_and_clamp";
            case stencil_op::decrement_and_clamp:
                return os << "decrement_and_clamp";
            case stencil_op::invert:
                return os << "invert";
            case stencil_op::increment_and_wrap:
                return os << "increment_and_wrap";
            case stencil_op::decrement_and_wrap:
                return os << "decrement_and_wrap";
            default:
                return os << "Unknown_stencil_op(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, stencil_op& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <stencil_op>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = stencil_op::invalid;
        } else if (str == "keep") {
            value = stencil_op::keep;
        } else if (str == "zero") {
            value = stencil_op::zero;
        } else if (str == "replace") {
            value = stencil_op::replace;
        } else if (str == "increment_and_clamp") {
            value = stencil_op::increment_and_clamp;
        } else if (str == "decrement_and_clamp") {
            value = stencil_op::decrement_and_clamp;
        } else if (str == "invert") {
            value = stencil_op::invert;
        } else if (str == "increment_and_wrap") {
            value = stencil_op::increment_and_wrap;
        } else if (str == "decrement_and_wrap") {
            value = stencil_op::decrement_and_wrap;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <stencil_op>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, blend_op value) {
        switch (value) {
            case blend_op::invalid:
                return os << "invalid";
            case blend_op::add:
                return os << "add";
            case blend_op::subtract:
                return os << "subtract";
            case blend_op::reverse_subtract:
                return os << "reverse_subtract";
            case blend_op::min:
                return os << "min";
            case blend_op::max:
                return os << "max";
            default:
                return os << "Unknown_blend_op(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, blend_op& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <blend_op>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = blend_op::invalid;
        } else if (str == "add") {
            value = blend_op::add;
        } else if (str == "subtract") {
            value = blend_op::subtract;
        } else if (str == "reverse_subtract") {
            value = blend_op::reverse_subtract;
        } else if (str == "min") {
            value = blend_op::min;
        } else if (str == "max") {
            value = blend_op::max;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <blend_op>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, blend_factor value) {
        switch (value) {
            case blend_factor::invalid:
                return os << "invalid";
            case blend_factor::zero:
                return os << "zero";
            case blend_factor::one:
                return os << "one";
            case blend_factor::src_color:
                return os << "src_color";
            case blend_factor::one_minus_src_color:
                return os << "one_minus_src_color";
            case blend_factor::dst_color:
                return os << "dst_color";
            case blend_factor::one_minus_dst_color:
                return os << "one_minus_dst_color";
            case blend_factor::src_alpha:
                return os << "src_alpha";
            case blend_factor::one_minus_src_alpha:
                return os << "one_minus_src_alpha";
            case blend_factor::dst_alpha:
                return os << "dst_alpha";
            case blend_factor::one_minus_dst_alpha:
                return os << "one_minus_dst_alpha";
            case blend_factor::constant_color:
                return os << "constant_color";
            case blend_factor::one_minus_constant_color:
                return os << "one_minus_constant_color";
            case blend_factor::src_alpha_saturate:
                return os << "src_alpha_saturate";
            default:
                return os << "Unknown_blend_factor(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, blend_factor& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <blend_factor>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = blend_factor::invalid;
        } else if (str == "zero") {
            value = blend_factor::zero;
        } else if (str == "one") {
            value = blend_factor::one;
        } else if (str == "src_color") {
            value = blend_factor::src_color;
        } else if (str == "one_minus_src_color") {
            value = blend_factor::one_minus_src_color;
        } else if (str == "dst_color") {
            value = blend_factor::dst_color;
        } else if (str == "one_minus_dst_color") {
            value = blend_factor::one_minus_dst_color;
        } else if (str == "src_alpha") {
            value = blend_factor::src_alpha;
        } else if (str == "one_minus_src_alpha") {
            value = blend_factor::one_minus_src_alpha;
        } else if (str == "dst_alpha") {
            value = blend_factor::dst_alpha;
        } else if (str == "one_minus_dst_alpha") {
            value = blend_factor::one_minus_dst_alpha;
        } else if (str == "constant_color") {
            value = blend_factor::constant_color;
        } else if (str == "one_minus_constant_color") {
            value = blend_factor::one_minus_constant_color;
        } else if (str == "src_alpha_saturate") {
            value = blend_factor::src_alpha_saturate;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <blend_factor>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, filter value) {
        switch (value) {
            case filter::nearest:
                return os << "nearest";
            case filter::linear:
                return os << "linear";
            default:
                return os << "Unknown_filter(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, filter& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <filter>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "nearest") {
            value = filter::nearest;
        } else if (str == "linear") {
            value = filter::linear;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <filter>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, sampler_mipmap_mode value) {
        switch (value) {
            case sampler_mipmap_mode::nearest:
                return os << "nearest";
            case sampler_mipmap_mode::linear:
                return os << "linear";
            default:
                return os << "Unknown_sampler_mipmap_mode(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, sampler_mipmap_mode& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <sampler_mipmap_mode>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "nearest") {
            value = sampler_mipmap_mode::nearest;
        } else if (str == "linear") {
            value = sampler_mipmap_mode::linear;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <sampler_mipmap_mode>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, sampler_address_mode value) {
        switch (value) {
            case sampler_address_mode::repeat:
                return os << "repeat";
            case sampler_address_mode::mirrored_repeat:
                return os << "mirrored_repeat";
            case sampler_address_mode::clamp_to_edge:
                return os << "clamp_to_edge";
            default:
                return os << "Unknown_sampler_address_mode(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, sampler_address_mode& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <sampler_address_mode>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "repeat") {
            value = sampler_address_mode::repeat;
        } else if (str == "mirrored_repeat") {
            value = sampler_address_mode::mirrored_repeat;
        } else if (str == "clamp_to_edge") {
            value = sampler_address_mode::clamp_to_edge;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <sampler_address_mode>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, texture_usage value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_usage::sampler)) != 0) {
            active_flags.emplace_back("sampler");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_usage::color_target)) != 0) {
            active_flags.emplace_back("color_target");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_usage::depth_stencil_target)) !=
            0) {
            active_flags.emplace_back("depth_stencil_target");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_usage::storage_read)) != 0) {
            active_flags.emplace_back("storage_read");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(texture_usage::storage_write)) != 0) {
            active_flags.emplace_back("storage_write");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(
                 texture_usage::compute_storage_simultaneous_read_write)) != 0) {
            active_flags.emplace_back("compute_storage_simultaneous_read_write");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, texture_usage& value) {
        std::string str;
        is >> str;

        value = static_cast <texture_usage>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <texture_usage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <texture_usage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "sampler") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_usage::sampler));
                found = true;
            }
            if (flag_name == "color_target") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_usage::color_target));
                found = true;
            }
            if (flag_name == "depth_stencil_target") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_usage::depth_stencil_target));
                found = true;
            }
            if (flag_name == "storage_read") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_usage::storage_read));
                found = true;
            }
            if (flag_name == "storage_write") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(texture_usage::storage_write));
                found = true;
            }
            if (flag_name == "compute_storage_simultaneous_read_write") {
                value = static_cast <texture_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        texture_usage::compute_storage_simultaneous_read_write));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <texture_usage>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, buffer_usage value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::vertex)) != 0) {
            active_flags.emplace_back("vertex");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::index)) != 0) {
            active_flags.emplace_back("index");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::indirect)) != 0) {
            active_flags.emplace_back("indirect");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::graphics_storage_read)) !=
            0) {
            active_flags.emplace_back("graphics_storage_read");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::compute_storage_read)) != 0) {
            active_flags.emplace_back("compute_storage_read");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(buffer_usage::compute_storage_write)) !=
            0) {
            active_flags.emplace_back("compute_storage_write");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, buffer_usage& value) {
        std::string str;
        is >> str;

        value = static_cast <buffer_usage>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <buffer_usage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <buffer_usage>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "vertex") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(buffer_usage::vertex));
                found = true;
            }
            if (flag_name == "index") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(buffer_usage::index));
                found = true;
            }
            if (flag_name == "indirect") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(buffer_usage::indirect));
                found = true;
            }
            if (flag_name == "graphics_storage_read") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        buffer_usage::graphics_storage_read));
                found = true;
            }
            if (flag_name == "compute_storage_read") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(buffer_usage::compute_storage_read));
                found = true;
            }
            if (flag_name == "compute_storage_write") {
                value = static_cast <buffer_usage>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(
                        buffer_usage::compute_storage_write));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <buffer_usage>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, color_component value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(color_component::r)) != 0) {
            active_flags.emplace_back("r");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(color_component::g)) != 0) {
            active_flags.emplace_back("g");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(color_component::b)) != 0) {
            active_flags.emplace_back("b");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(color_component::a)) != 0) {
            active_flags.emplace_back("a");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, color_component& value) {
        std::string str;
        is >> str;

        value = static_cast <color_component>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <color_component>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <color_component>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "r") {
                value = static_cast <color_component>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(color_component::r));
                found = true;
            }
            if (flag_name == "g") {
                value = static_cast <color_component>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(color_component::g));
                found = true;
            }
            if (flag_name == "b") {
                value = static_cast <color_component>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(color_component::b));
                found = true;
            }
            if (flag_name == "a") {
                value = static_cast <color_component>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(color_component::a));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <color_component>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }
} // namespace sdlpp::gpu
