/**
 * @file time.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/core/time.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, day_of_week value) {
        switch (value) {
            case day_of_week::sunday:
                return os << "sunday";
            case day_of_week::monday:
                return os << "monday";
            case day_of_week::tuesday:
                return os << "tuesday";
            case day_of_week::wednesday:
                return os << "wednesday";
            case day_of_week::thursday:
                return os << "thursday";
            case day_of_week::friday:
                return os << "friday";
            case day_of_week::saturday:
                return os << "saturday";
            default:
                return os << "Unknown_day_of_week(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, day_of_week& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <day_of_week>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "sunday") {
            value = day_of_week::sunday;
        } else if (str == "monday") {
            value = day_of_week::monday;
        } else if (str == "tuesday") {
            value = day_of_week::tuesday;
        } else if (str == "wednesday") {
            value = day_of_week::wednesday;
        } else if (str == "thursday") {
            value = day_of_week::thursday;
        } else if (str == "friday") {
            value = day_of_week::friday;
        } else if (str == "saturday") {
            value = day_of_week::saturday;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <day_of_week>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, date_format value) {
        switch (value) {
            case date_format::yyyy_mm_dd:
                return os << "yyyy_mm_dd";
            case date_format::dd_mm_yyyy:
                return os << "dd_mm_yyyy";
            case date_format::mm_dd_yyyy:
                return os << "mm_dd_yyyy";
            default:
                return os << "Unknown_date_format(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, date_format& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <date_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "yyyy_mm_dd") {
            value = date_format::yyyy_mm_dd;
        } else if (str == "dd_mm_yyyy") {
            value = date_format::dd_mm_yyyy;
        } else if (str == "mm_dd_yyyy") {
            value = date_format::mm_dd_yyyy;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <date_format>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, time_format value) {
        switch (value) {
            case time_format::hour_24:
                return os << "hour_24";
            case time_format::hour_12:
                return os << "hour_12";
            default:
                return os << "Unknown_time_format(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, time_format& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <time_format>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "hour_24") {
            value = time_format::hour_24;
        } else if (str == "hour_12") {
            value = time_format::hour_12;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <time_format>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }
} // namespace
