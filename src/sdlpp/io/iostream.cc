/**
 * @file iostream.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/io/iostream.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, io_seek_pos value) {
        switch (value) {
            case io_seek_pos::set:
                return os << "set";
            case io_seek_pos::current:
                return os << "current";
            case io_seek_pos::end:
                return os << "end";
            default:
                return os << "Unknown_io_seek_pos(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, io_seek_pos& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <io_seek_pos>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "set") {
            value = io_seek_pos::set;
        } else if (str == "current") {
            value = io_seek_pos::current;
        } else if (str == "end") {
            value = io_seek_pos::end;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <io_seek_pos>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, io_status value) {
        switch (value) {
            case io_status::ready:
                return os << "ready";
            case io_status::error:
                return os << "error";
            case io_status::eof:
                return os << "eof";
            case io_status::not_ready:
                return os << "not_ready";
            case io_status::read_only:
                return os << "read_only";
            case io_status::write_only:
                return os << "write_only";
            default:
                return os << "Unknown_io_status(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, io_status& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <io_status>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "ready") {
            value = io_status::ready;
        } else if (str == "error") {
            value = io_status::error;
        } else if (str == "eof") {
            value = io_status::eof;
        } else if (str == "not_ready") {
            value = io_status::not_ready;
        } else if (str == "read_only") {
            value = io_status::read_only;
        } else if (str == "write_only") {
            value = io_status::write_only;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <io_status>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }
} // namespace
