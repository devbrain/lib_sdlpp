/**
 * @file keyboard_codes.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/events/keyboard_codes.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
#include <vector>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, scancode value) {
        switch (value) {
            case scancode::unknown:
                return os << "unknown";
            case scancode::a:
                return os << "a";
            case scancode::b:
                return os << "b";
            case scancode::c:
                return os << "c";
            case scancode::d:
                return os << "d";
            case scancode::e:
                return os << "e";
            case scancode::f:
                return os << "f";
            case scancode::g:
                return os << "g";
            case scancode::h:
                return os << "h";
            case scancode::i:
                return os << "i";
            case scancode::j:
                return os << "j";
            case scancode::k:
                return os << "k";
            case scancode::l:
                return os << "l";
            case scancode::m:
                return os << "m";
            case scancode::n:
                return os << "n";
            case scancode::o:
                return os << "o";
            case scancode::p:
                return os << "p";
            case scancode::q:
                return os << "q";
            case scancode::r:
                return os << "r";
            case scancode::s:
                return os << "s";
            case scancode::t:
                return os << "t";
            case scancode::u:
                return os << "u";
            case scancode::v:
                return os << "v";
            case scancode::w:
                return os << "w";
            case scancode::x:
                return os << "x";
            case scancode::y:
                return os << "y";
            case scancode::z:
                return os << "z";
            case scancode::num_1:
                return os << "num_1";
            case scancode::num_2:
                return os << "num_2";
            case scancode::num_3:
                return os << "num_3";
            case scancode::num_4:
                return os << "num_4";
            case scancode::num_5:
                return os << "num_5";
            case scancode::num_6:
                return os << "num_6";
            case scancode::num_7:
                return os << "num_7";
            case scancode::num_8:
                return os << "num_8";
            case scancode::num_9:
                return os << "num_9";
            case scancode::num_0:
                return os << "num_0";
            case scancode::f1:
                return os << "f1";
            case scancode::f2:
                return os << "f2";
            case scancode::f3:
                return os << "f3";
            case scancode::f4:
                return os << "f4";
            case scancode::f5:
                return os << "f5";
            case scancode::f6:
                return os << "f6";
            case scancode::f7:
                return os << "f7";
            case scancode::f8:
                return os << "f8";
            case scancode::f9:
                return os << "f9";
            case scancode::f10:
                return os << "f10";
            case scancode::f11:
                return os << "f11";
            case scancode::f12:
                return os << "f12";
            case scancode::f13:
                return os << "f13";
            case scancode::f14:
                return os << "f14";
            case scancode::f15:
                return os << "f15";
            case scancode::f16:
                return os << "f16";
            case scancode::f17:
                return os << "f17";
            case scancode::f18:
                return os << "f18";
            case scancode::f19:
                return os << "f19";
            case scancode::f20:
                return os << "f20";
            case scancode::f21:
                return os << "f21";
            case scancode::f22:
                return os << "f22";
            case scancode::f23:
                return os << "f23";
            case scancode::f24:
                return os << "f24";
            case scancode::return_key:
                return os << "return_key";
            case scancode::escape:
                return os << "escape";
            case scancode::backspace:
                return os << "backspace";
            case scancode::tab:
                return os << "tab";
            case scancode::space:
                return os << "space";
            case scancode::minus:
                return os << "minus";
            case scancode::equals:
                return os << "equals";
            case scancode::leftbracket:
                return os << "leftbracket";
            case scancode::rightbracket:
                return os << "rightbracket";
            case scancode::backslash:
                return os << "backslash";
            case scancode::nonushash:
                return os << "nonushash";
            case scancode::semicolon:
                return os << "semicolon";
            case scancode::apostrophe:
                return os << "apostrophe";
            case scancode::grave:
                return os << "grave";
            case scancode::comma:
                return os << "comma";
            case scancode::period:
                return os << "period";
            case scancode::slash:
                return os << "slash";
            case scancode::capslock:
                return os << "capslock";
            case scancode::scrolllock:
                return os << "scrolllock";
            case scancode::numlockclear:
                return os << "numlockclear";
            case scancode::printscreen:
                return os << "printscreen";
            case scancode::pause:
                return os << "pause";
            case scancode::insert:
                return os << "insert";
            case scancode::home:
                return os << "home";
            case scancode::pageup:
                return os << "pageup";
            case scancode::delete_key:
                return os << "delete_key";
            case scancode::end:
                return os << "end";
            case scancode::pagedown:
                return os << "pagedown";
            case scancode::right:
                return os << "right";
            case scancode::left:
                return os << "left";
            case scancode::down:
                return os << "down";
            case scancode::up:
                return os << "up";
            case scancode::kp_divide:
                return os << "kp_divide";
            case scancode::kp_multiply:
                return os << "kp_multiply";
            case scancode::kp_minus:
                return os << "kp_minus";
            case scancode::kp_plus:
                return os << "kp_plus";
            case scancode::kp_enter:
                return os << "kp_enter";
            case scancode::kp_1:
                return os << "kp_1";
            case scancode::kp_2:
                return os << "kp_2";
            case scancode::kp_3:
                return os << "kp_3";
            case scancode::kp_4:
                return os << "kp_4";
            case scancode::kp_5:
                return os << "kp_5";
            case scancode::kp_6:
                return os << "kp_6";
            case scancode::kp_7:
                return os << "kp_7";
            case scancode::kp_8:
                return os << "kp_8";
            case scancode::kp_9:
                return os << "kp_9";
            case scancode::kp_0:
                return os << "kp_0";
            case scancode::kp_period:
                return os << "kp_period";
            case scancode::lctrl:
                return os << "lctrl";
            case scancode::lshift:
                return os << "lshift";
            case scancode::lalt:
                return os << "lalt";
            case scancode::lgui:
                return os << "lgui";
            case scancode::rctrl:
                return os << "rctrl";
            case scancode::rshift:
                return os << "rshift";
            case scancode::ralt:
                return os << "ralt";
            case scancode::rgui:
                return os << "rgui";
            case scancode::application:
                return os << "application";
            case scancode::power:
                return os << "power";
            case scancode::execute:
                return os << "execute";
            case scancode::help:
                return os << "help";
            case scancode::menu:
                return os << "menu";
            case scancode::select:
                return os << "select";
            case scancode::stop:
                return os << "stop";
            case scancode::again:
                return os << "again";
            case scancode::undo:
                return os << "undo";
            case scancode::cut:
                return os << "cut";
            case scancode::copy:
                return os << "copy";
            case scancode::paste:
                return os << "paste";
            case scancode::find:
                return os << "find";
            case scancode::mute:
                return os << "mute";
            case scancode::volumeup:
                return os << "volumeup";
            case scancode::volumedown:
                return os << "volumedown";
            case scancode::count:
                return os << "count";
            default:
                return os << "Unknown_scancode(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, scancode& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <scancode>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "unknown") {
            value = scancode::unknown;
        } else if (str == "a") {
            value = scancode::a;
        } else if (str == "b") {
            value = scancode::b;
        } else if (str == "c") {
            value = scancode::c;
        } else if (str == "d") {
            value = scancode::d;
        } else if (str == "e") {
            value = scancode::e;
        } else if (str == "f") {
            value = scancode::f;
        } else if (str == "g") {
            value = scancode::g;
        } else if (str == "h") {
            value = scancode::h;
        } else if (str == "i") {
            value = scancode::i;
        } else if (str == "j") {
            value = scancode::j;
        } else if (str == "k") {
            value = scancode::k;
        } else if (str == "l") {
            value = scancode::l;
        } else if (str == "m") {
            value = scancode::m;
        } else if (str == "n") {
            value = scancode::n;
        } else if (str == "o") {
            value = scancode::o;
        } else if (str == "p") {
            value = scancode::p;
        } else if (str == "q") {
            value = scancode::q;
        } else if (str == "r") {
            value = scancode::r;
        } else if (str == "s") {
            value = scancode::s;
        } else if (str == "t") {
            value = scancode::t;
        } else if (str == "u") {
            value = scancode::u;
        } else if (str == "v") {
            value = scancode::v;
        } else if (str == "w") {
            value = scancode::w;
        } else if (str == "x") {
            value = scancode::x;
        } else if (str == "y") {
            value = scancode::y;
        } else if (str == "z") {
            value = scancode::z;
        } else if (str == "num_1") {
            value = scancode::num_1;
        } else if (str == "num_2") {
            value = scancode::num_2;
        } else if (str == "num_3") {
            value = scancode::num_3;
        } else if (str == "num_4") {
            value = scancode::num_4;
        } else if (str == "num_5") {
            value = scancode::num_5;
        } else if (str == "num_6") {
            value = scancode::num_6;
        } else if (str == "num_7") {
            value = scancode::num_7;
        } else if (str == "num_8") {
            value = scancode::num_8;
        } else if (str == "num_9") {
            value = scancode::num_9;
        } else if (str == "num_0") {
            value = scancode::num_0;
        } else if (str == "f1") {
            value = scancode::f1;
        } else if (str == "f2") {
            value = scancode::f2;
        } else if (str == "f3") {
            value = scancode::f3;
        } else if (str == "f4") {
            value = scancode::f4;
        } else if (str == "f5") {
            value = scancode::f5;
        } else if (str == "f6") {
            value = scancode::f6;
        } else if (str == "f7") {
            value = scancode::f7;
        } else if (str == "f8") {
            value = scancode::f8;
        } else if (str == "f9") {
            value = scancode::f9;
        } else if (str == "f10") {
            value = scancode::f10;
        } else if (str == "f11") {
            value = scancode::f11;
        } else if (str == "f12") {
            value = scancode::f12;
        } else if (str == "f13") {
            value = scancode::f13;
        } else if (str == "f14") {
            value = scancode::f14;
        } else if (str == "f15") {
            value = scancode::f15;
        } else if (str == "f16") {
            value = scancode::f16;
        } else if (str == "f17") {
            value = scancode::f17;
        } else if (str == "f18") {
            value = scancode::f18;
        } else if (str == "f19") {
            value = scancode::f19;
        } else if (str == "f20") {
            value = scancode::f20;
        } else if (str == "f21") {
            value = scancode::f21;
        } else if (str == "f22") {
            value = scancode::f22;
        } else if (str == "f23") {
            value = scancode::f23;
        } else if (str == "f24") {
            value = scancode::f24;
        } else if (str == "return_key") {
            value = scancode::return_key;
        } else if (str == "escape") {
            value = scancode::escape;
        } else if (str == "backspace") {
            value = scancode::backspace;
        } else if (str == "tab") {
            value = scancode::tab;
        } else if (str == "space") {
            value = scancode::space;
        } else if (str == "minus") {
            value = scancode::minus;
        } else if (str == "equals") {
            value = scancode::equals;
        } else if (str == "leftbracket") {
            value = scancode::leftbracket;
        } else if (str == "rightbracket") {
            value = scancode::rightbracket;
        } else if (str == "backslash") {
            value = scancode::backslash;
        } else if (str == "nonushash") {
            value = scancode::nonushash;
        } else if (str == "semicolon") {
            value = scancode::semicolon;
        } else if (str == "apostrophe") {
            value = scancode::apostrophe;
        } else if (str == "grave") {
            value = scancode::grave;
        } else if (str == "comma") {
            value = scancode::comma;
        } else if (str == "period") {
            value = scancode::period;
        } else if (str == "slash") {
            value = scancode::slash;
        } else if (str == "capslock") {
            value = scancode::capslock;
        } else if (str == "scrolllock") {
            value = scancode::scrolllock;
        } else if (str == "numlockclear") {
            value = scancode::numlockclear;
        } else if (str == "printscreen") {
            value = scancode::printscreen;
        } else if (str == "pause") {
            value = scancode::pause;
        } else if (str == "insert") {
            value = scancode::insert;
        } else if (str == "home") {
            value = scancode::home;
        } else if (str == "pageup") {
            value = scancode::pageup;
        } else if (str == "delete_key") {
            value = scancode::delete_key;
        } else if (str == "end") {
            value = scancode::end;
        } else if (str == "pagedown") {
            value = scancode::pagedown;
        } else if (str == "right") {
            value = scancode::right;
        } else if (str == "left") {
            value = scancode::left;
        } else if (str == "down") {
            value = scancode::down;
        } else if (str == "up") {
            value = scancode::up;
        } else if (str == "kp_divide") {
            value = scancode::kp_divide;
        } else if (str == "kp_multiply") {
            value = scancode::kp_multiply;
        } else if (str == "kp_minus") {
            value = scancode::kp_minus;
        } else if (str == "kp_plus") {
            value = scancode::kp_plus;
        } else if (str == "kp_enter") {
            value = scancode::kp_enter;
        } else if (str == "kp_1") {
            value = scancode::kp_1;
        } else if (str == "kp_2") {
            value = scancode::kp_2;
        } else if (str == "kp_3") {
            value = scancode::kp_3;
        } else if (str == "kp_4") {
            value = scancode::kp_4;
        } else if (str == "kp_5") {
            value = scancode::kp_5;
        } else if (str == "kp_6") {
            value = scancode::kp_6;
        } else if (str == "kp_7") {
            value = scancode::kp_7;
        } else if (str == "kp_8") {
            value = scancode::kp_8;
        } else if (str == "kp_9") {
            value = scancode::kp_9;
        } else if (str == "kp_0") {
            value = scancode::kp_0;
        } else if (str == "kp_period") {
            value = scancode::kp_period;
        } else if (str == "lctrl") {
            value = scancode::lctrl;
        } else if (str == "lshift") {
            value = scancode::lshift;
        } else if (str == "lalt") {
            value = scancode::lalt;
        } else if (str == "lgui") {
            value = scancode::lgui;
        } else if (str == "rctrl") {
            value = scancode::rctrl;
        } else if (str == "rshift") {
            value = scancode::rshift;
        } else if (str == "ralt") {
            value = scancode::ralt;
        } else if (str == "rgui") {
            value = scancode::rgui;
        } else if (str == "application") {
            value = scancode::application;
        } else if (str == "power") {
            value = scancode::power;
        } else if (str == "execute") {
            value = scancode::execute;
        } else if (str == "help") {
            value = scancode::help;
        } else if (str == "menu") {
            value = scancode::menu;
        } else if (str == "select") {
            value = scancode::select;
        } else if (str == "stop") {
            value = scancode::stop;
        } else if (str == "again") {
            value = scancode::again;
        } else if (str == "undo") {
            value = scancode::undo;
        } else if (str == "cut") {
            value = scancode::cut;
        } else if (str == "copy") {
            value = scancode::copy;
        } else if (str == "paste") {
            value = scancode::paste;
        } else if (str == "find") {
            value = scancode::find;
        } else if (str == "mute") {
            value = scancode::mute;
        } else if (str == "volumeup") {
            value = scancode::volumeup;
        } else if (str == "volumedown") {
            value = scancode::volumedown;
        } else if (str == "count") {
            value = scancode::count;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <scancode>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, keymod value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::none)) != 0) {
            active_flags.emplace_back("none");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::lshift)) != 0) {
            active_flags.emplace_back("lshift");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::rshift)) != 0) {
            active_flags.emplace_back("rshift");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::lctrl)) != 0) {
            active_flags.emplace_back("lctrl");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::rctrl)) != 0) {
            active_flags.emplace_back("rctrl");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::lalt)) != 0) {
            active_flags.emplace_back("lalt");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::ralt)) != 0) {
            active_flags.emplace_back("ralt");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::lgui)) != 0) {
            active_flags.emplace_back("lgui");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::rgui)) != 0) {
            active_flags.emplace_back("rgui");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::num)) != 0) {
            active_flags.emplace_back("num");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::caps)) != 0) {
            active_flags.emplace_back("caps");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::mode)) != 0) {
            active_flags.emplace_back("mode");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::scroll)) != 0) {
            active_flags.emplace_back("scroll");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::ctrl)) != 0) {
            active_flags.emplace_back("ctrl");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::shift)) != 0) {
            active_flags.emplace_back("shift");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::alt)) != 0) {
            active_flags.emplace_back("alt");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(keymod::gui)) != 0) {
            active_flags.emplace_back("gui");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, keymod& value) {
        std::string str;
        is >> str;

        value = static_cast <keymod>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <keymod>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <keymod>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "none") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::none));
                found = true;
            }
            if (flag_name == "lshift") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::lshift));
                found = true;
            }
            if (flag_name == "rshift") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::rshift));
                found = true;
            }
            if (flag_name == "lctrl") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::lctrl));
                found = true;
            }
            if (flag_name == "rctrl") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::rctrl));
                found = true;
            }
            if (flag_name == "lalt") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::lalt));
                found = true;
            }
            if (flag_name == "ralt") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::ralt));
                found = true;
            }
            if (flag_name == "lgui") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::lgui));
                found = true;
            }
            if (flag_name == "rgui") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::rgui));
                found = true;
            }
            if (flag_name == "num") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::num));
                found = true;
            }
            if (flag_name == "caps") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::caps));
                found = true;
            }
            if (flag_name == "mode") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::mode));
                found = true;
            }
            if (flag_name == "scroll") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::scroll));
                found = true;
            }
            if (flag_name == "ctrl") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::ctrl));
                found = true;
            }
            if (flag_name == "shift") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::shift));
                found = true;
            }
            if (flag_name == "alt") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::alt));
                found = true;
            }
            if (flag_name == "gui") {
                value = static_cast <keymod>(static_cast <unsigned int>(value) | static_cast <unsigned int>(
                                                 keymod::gui));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <keymod>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }
} // namespace
