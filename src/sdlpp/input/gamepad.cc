/**
 * @file gamepad.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/input/gamepad.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, gamepad_type value) {
        switch (value) {
            case gamepad_type::unknown:
                return os << "unknown";
            case gamepad_type::standard:
                return os << "standard";
            case gamepad_type::xbox360:
                return os << "xbox360";
            case gamepad_type::xboxone:
                return os << "xboxone";
            case gamepad_type::ps3:
                return os << "ps3";
            case gamepad_type::ps4:
                return os << "ps4";
            case gamepad_type::ps5:
                return os << "ps5";
            case gamepad_type::nintendo_switch_pro:
                return os << "nintendo_switch_pro";
            case gamepad_type::nintendo_switch_joycon_left:
                return os << "nintendo_switch_joycon_left";
            case gamepad_type::nintendo_switch_joycon_right:
                return os << "nintendo_switch_joycon_right";
            case gamepad_type::nintendo_switch_joycon_pair:
                return os << "nintendo_switch_joycon_pair";
            default:
                return os << "Unknown_gamepad_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, gamepad_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <gamepad_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "unknown") {
            value = gamepad_type::unknown;
        } else if (str == "standard") {
            value = gamepad_type::standard;
        } else if (str == "xbox360") {
            value = gamepad_type::xbox360;
        } else if (str == "xboxone") {
            value = gamepad_type::xboxone;
        } else if (str == "ps3") {
            value = gamepad_type::ps3;
        } else if (str == "ps4") {
            value = gamepad_type::ps4;
        } else if (str == "ps5") {
            value = gamepad_type::ps5;
        } else if (str == "nintendo_switch_pro") {
            value = gamepad_type::nintendo_switch_pro;
        } else if (str == "nintendo_switch_joycon_left") {
            value = gamepad_type::nintendo_switch_joycon_left;
        } else if (str == "nintendo_switch_joycon_right") {
            value = gamepad_type::nintendo_switch_joycon_right;
        } else if (str == "nintendo_switch_joycon_pair") {
            value = gamepad_type::nintendo_switch_joycon_pair;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <gamepad_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, gamepad_axis value) {
        switch (value) {
            case gamepad_axis::invalid:
                return os << "invalid";
            case gamepad_axis::leftx:
                return os << "leftx";
            case gamepad_axis::lefty:
                return os << "lefty";
            case gamepad_axis::rightx:
                return os << "rightx";
            case gamepad_axis::righty:
                return os << "righty";
            case gamepad_axis::left_trigger:
                return os << "left_trigger";
            case gamepad_axis::right_trigger:
                return os << "right_trigger";
            case gamepad_axis::max:
                return os << "max";
            default:
                return os << "Unknown_gamepad_axis(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, gamepad_axis& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <gamepad_axis>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = gamepad_axis::invalid;
        } else if (str == "leftx") {
            value = gamepad_axis::leftx;
        } else if (str == "lefty") {
            value = gamepad_axis::lefty;
        } else if (str == "rightx") {
            value = gamepad_axis::rightx;
        } else if (str == "righty") {
            value = gamepad_axis::righty;
        } else if (str == "left_trigger") {
            value = gamepad_axis::left_trigger;
        } else if (str == "right_trigger") {
            value = gamepad_axis::right_trigger;
        } else if (str == "max") {
            value = gamepad_axis::max;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <gamepad_axis>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, gamepad_button value) {
        switch (value) {
            case gamepad_button::invalid:
                return os << "invalid";
            case gamepad_button::south:
                return os << "south";
            case gamepad_button::east:
                return os << "east";
            case gamepad_button::west:
                return os << "west";
            case gamepad_button::north:
                return os << "north";
            case gamepad_button::back:
                return os << "back";
            case gamepad_button::guide:
                return os << "guide";
            case gamepad_button::start:
                return os << "start";
            case gamepad_button::left_stick:
                return os << "left_stick";
            case gamepad_button::right_stick:
                return os << "right_stick";
            case gamepad_button::left_shoulder:
                return os << "left_shoulder";
            case gamepad_button::right_shoulder:
                return os << "right_shoulder";
            case gamepad_button::dpad_up:
                return os << "dpad_up";
            case gamepad_button::dpad_down:
                return os << "dpad_down";
            case gamepad_button::dpad_left:
                return os << "dpad_left";
            case gamepad_button::dpad_right:
                return os << "dpad_right";
            case gamepad_button::misc1:
                return os << "misc1";
            case gamepad_button::misc2:
                return os << "misc2";
            case gamepad_button::misc3:
                return os << "misc3";
            case gamepad_button::misc4:
                return os << "misc4";
            case gamepad_button::misc5:
                return os << "misc5";
            case gamepad_button::misc6:
                return os << "misc6";
            case gamepad_button::left_paddle1:
                return os << "left_paddle1";
            case gamepad_button::left_paddle2:
                return os << "left_paddle2";
            case gamepad_button::right_paddle1:
                return os << "right_paddle1";
            case gamepad_button::right_paddle2:
                return os << "right_paddle2";
            case gamepad_button::touchpad:
                return os << "touchpad";
            case gamepad_button::max:
                return os << "max";
            default:
                return os << "Unknown_gamepad_button(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, gamepad_button& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <gamepad_button>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = gamepad_button::invalid;
        } else if (str == "south") {
            value = gamepad_button::south;
        } else if (str == "east") {
            value = gamepad_button::east;
        } else if (str == "west") {
            value = gamepad_button::west;
        } else if (str == "north") {
            value = gamepad_button::north;
        } else if (str == "back") {
            value = gamepad_button::back;
        } else if (str == "guide") {
            value = gamepad_button::guide;
        } else if (str == "start") {
            value = gamepad_button::start;
        } else if (str == "left_stick") {
            value = gamepad_button::left_stick;
        } else if (str == "right_stick") {
            value = gamepad_button::right_stick;
        } else if (str == "left_shoulder") {
            value = gamepad_button::left_shoulder;
        } else if (str == "right_shoulder") {
            value = gamepad_button::right_shoulder;
        } else if (str == "dpad_up") {
            value = gamepad_button::dpad_up;
        } else if (str == "dpad_down") {
            value = gamepad_button::dpad_down;
        } else if (str == "dpad_left") {
            value = gamepad_button::dpad_left;
        } else if (str == "dpad_right") {
            value = gamepad_button::dpad_right;
        } else if (str == "misc1") {
            value = gamepad_button::misc1;
        } else if (str == "misc2") {
            value = gamepad_button::misc2;
        } else if (str == "misc3") {
            value = gamepad_button::misc3;
        } else if (str == "misc4") {
            value = gamepad_button::misc4;
        } else if (str == "misc5") {
            value = gamepad_button::misc5;
        } else if (str == "misc6") {
            value = gamepad_button::misc6;
        } else if (str == "left_paddle1") {
            value = gamepad_button::left_paddle1;
        } else if (str == "left_paddle2") {
            value = gamepad_button::left_paddle2;
        } else if (str == "right_paddle1") {
            value = gamepad_button::right_paddle1;
        } else if (str == "right_paddle2") {
            value = gamepad_button::right_paddle2;
        } else if (str == "touchpad") {
            value = gamepad_button::touchpad;
        } else if (str == "max") {
            value = gamepad_button::max;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <gamepad_button>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, gamepad_button_label value) {
        switch (value) {
            case gamepad_button_label::unknown:
                return os << "unknown";
            case gamepad_button_label::a:
                return os << "a";
            case gamepad_button_label::b:
                return os << "b";
            case gamepad_button_label::x:
                return os << "x";
            case gamepad_button_label::y:
                return os << "y";
            case gamepad_button_label::cross:
                return os << "cross";
            case gamepad_button_label::circle:
                return os << "circle";
            case gamepad_button_label::square:
                return os << "square";
            case gamepad_button_label::triangle:
                return os << "triangle";
            default:
                return os << "Unknown_gamepad_button_label(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, gamepad_button_label& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <gamepad_button_label>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "unknown") {
            value = gamepad_button_label::unknown;
        } else if (str == "a") {
            value = gamepad_button_label::a;
        } else if (str == "b") {
            value = gamepad_button_label::b;
        } else if (str == "x") {
            value = gamepad_button_label::x;
        } else if (str == "y") {
            value = gamepad_button_label::y;
        } else if (str == "cross") {
            value = gamepad_button_label::cross;
        } else if (str == "circle") {
            value = gamepad_button_label::circle;
        } else if (str == "square") {
            value = gamepad_button_label::square;
        } else if (str == "triangle") {
            value = gamepad_button_label::triangle;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <gamepad_button_label>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, gamepad_sensor_type value) {
        switch (value) {
            case gamepad_sensor_type::invalid:
                return os << "invalid";
            case gamepad_sensor_type::unknown:
                return os << "unknown";
            case gamepad_sensor_type::accel:
                return os << "accel";
            case gamepad_sensor_type::gyro:
                return os << "gyro";
            case gamepad_sensor_type::accel_l:
                return os << "accel_l";
            case gamepad_sensor_type::gyro_l:
                return os << "gyro_l";
            case gamepad_sensor_type::accel_r:
                return os << "accel_r";
            case gamepad_sensor_type::gyro_r:
                return os << "gyro_r";
            default:
                return os << "Unknown_gamepad_sensor_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, gamepad_sensor_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <gamepad_sensor_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = gamepad_sensor_type::invalid;
        } else if (str == "unknown") {
            value = gamepad_sensor_type::unknown;
        } else if (str == "accel") {
            value = gamepad_sensor_type::accel;
        } else if (str == "gyro") {
            value = gamepad_sensor_type::gyro;
        } else if (str == "accel_l") {
            value = gamepad_sensor_type::accel_l;
        } else if (str == "gyro_l") {
            value = gamepad_sensor_type::gyro_l;
        } else if (str == "accel_r") {
            value = gamepad_sensor_type::accel_r;
        } else if (str == "gyro_r") {
            value = gamepad_sensor_type::gyro_r;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <gamepad_sensor_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }
} // namespace
