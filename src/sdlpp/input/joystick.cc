/**
 * @file joystick.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/input/joystick.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, joystick_type value) {
        switch (value) {
            case joystick_type::unknown:
                return os << "unknown";
            case joystick_type::gamepad:
                return os << "gamepad";
            case joystick_type::wheel:
                return os << "wheel";
            case joystick_type::arcade_stick:
                return os << "arcade_stick";
            case joystick_type::flight_stick:
                return os << "flight_stick";
            case joystick_type::dance_pad:
                return os << "dance_pad";
            case joystick_type::guitar:
                return os << "guitar";
            case joystick_type::drum_kit:
                return os << "drum_kit";
            case joystick_type::arcade_pad:
                return os << "arcade_pad";
            case joystick_type::throttle:
                return os << "throttle";
            default:
                return os << "Unknown_joystick_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, joystick_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <joystick_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "unknown") {
            value = joystick_type::unknown;
        } else if (str == "gamepad") {
            value = joystick_type::gamepad;
        } else if (str == "wheel") {
            value = joystick_type::wheel;
        } else if (str == "arcade_stick") {
            value = joystick_type::arcade_stick;
        } else if (str == "flight_stick") {
            value = joystick_type::flight_stick;
        } else if (str == "dance_pad") {
            value = joystick_type::dance_pad;
        } else if (str == "guitar") {
            value = joystick_type::guitar;
        } else if (str == "drum_kit") {
            value = joystick_type::drum_kit;
        } else if (str == "arcade_pad") {
            value = joystick_type::arcade_pad;
        } else if (str == "throttle") {
            value = joystick_type::throttle;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <joystick_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, joystick_connection_state value) {
        switch (value) {
            case joystick_connection_state::invalid:
                return os << "invalid";
            case joystick_connection_state::unknown:
                return os << "unknown";
            case joystick_connection_state::wired:
                return os << "wired";
            case joystick_connection_state::wireless:
                return os << "wireless";
            default:
                return os << "Unknown_joystick_connection_state(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, joystick_connection_state& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <joystick_connection_state>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "invalid") {
            value = joystick_connection_state::invalid;
        } else if (str == "unknown") {
            value = joystick_connection_state::unknown;
        } else if (str == "wired") {
            value = joystick_connection_state::wired;
        } else if (str == "wireless") {
            value = joystick_connection_state::wireless;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <joystick_connection_state>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, hat_position value) {
        switch (value) {
            case hat_position::centered:
                return os << "centered";
            case hat_position::up:
                return os << "up";
            case hat_position::right:
                return os << "right";
            case hat_position::down:
                return os << "down";
            case hat_position::left:
                return os << "left";
            case hat_position::rightup:
                return os << "rightup";
            case hat_position::rightdown:
                return os << "rightdown";
            case hat_position::leftup:
                return os << "leftup";
            case hat_position::leftdown:
                return os << "leftdown";
            default:
                return os << "Unknown_hat_position(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, hat_position& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <hat_position>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "centered") {
            value = hat_position::centered;
        } else if (str == "up") {
            value = hat_position::up;
        } else if (str == "right") {
            value = hat_position::right;
        } else if (str == "down") {
            value = hat_position::down;
        } else if (str == "left") {
            value = hat_position::left;
        } else if (str == "rightup") {
            value = hat_position::rightup;
        } else if (str == "rightdown") {
            value = hat_position::rightdown;
        } else if (str == "leftup") {
            value = hat_position::leftup;
        } else if (str == "leftdown") {
            value = hat_position::leftdown;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <hat_position>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }
} // namespace
