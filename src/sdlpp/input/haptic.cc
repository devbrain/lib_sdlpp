/**
 * @file haptic.cc
 * @brief Stream operator implementations for enums
 * @note This file is auto-generated by generate_enum_operators.py
 */

#include <sdlpp/input/haptic.hh>
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
#include <vector>

namespace sdlpp {
    std::ostream& operator<<(std::ostream& os, haptic_feature value) {
        // Check if hex output is requested
        if (os.flags() & std::ios::hex) {
            // Output as hex value
            os << static_cast <unsigned int>(value);
            return os;
        }

        // Output as human-readable flag names
        std::vector <std::string> active_flags;

        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::constant)) != 0) {
            active_flags.push_back("constant");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::sine)) != 0) {
            active_flags.push_back("sine");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::square)) != 0) {
            active_flags.push_back("square");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::triangle)) != 0) {
            active_flags.push_back("triangle");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::sawtoothup)) != 0) {
            active_flags.push_back("sawtoothup");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::sawtoothdown)) != 0) {
            active_flags.push_back("sawtoothdown");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::ramp)) != 0) {
            active_flags.push_back("ramp");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::spring)) != 0) {
            active_flags.push_back("spring");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::damper)) != 0) {
            active_flags.push_back("damper");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::inertia)) != 0) {
            active_flags.push_back("inertia");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::friction)) != 0) {
            active_flags.push_back("friction");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::leftright)) != 0) {
            active_flags.push_back("leftright");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::custom)) != 0) {
            active_flags.push_back("custom");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::gain)) != 0) {
            active_flags.push_back("gain");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::autocenter)) != 0) {
            active_flags.push_back("autocenter");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::status)) != 0) {
            active_flags.push_back("status");
        }
        if ((static_cast <unsigned int>(value) & static_cast <unsigned int>(haptic_feature::pause)) != 0) {
            active_flags.push_back("pause");
        }

        // Sort flags lexicographically
        std::sort(active_flags.begin(), active_flags.end());

        if (active_flags.empty()) {
            os << "none";
        } else {
            bool first = true;
            for (const auto& flag : active_flags) {
                if (!first) os << " | ";
                os << flag;
                first = false;
            }
        }
        return os;
    }

    std::istream& operator>>(std::istream& is, haptic_feature& value) {
        std::string str;
        is >> str;

        value = static_cast <haptic_feature>(0);

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <haptic_feature>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Check for explicit hex format (0x...)
        if (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X") {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <haptic_feature>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Parse as flag names separated by |
        size_t start = 0;
        size_t pos = 0;

        while (start < str.length()) {
            pos = str.find('|', start);
            std::string flag_name = (pos == std::string::npos) ? str.substr(start) : str.substr(start, pos - start);

            // Trim whitespace
            size_t first = flag_name.find_first_not_of(' ');
            size_t last = flag_name.find_last_not_of(' ');
            if (first != std::string::npos && last != std::string::npos) {
                flag_name = flag_name.substr(first, last - first + 1);
            }

            // Convert to lowercase
            std::transform(flag_name.begin(), flag_name.end(), flag_name.begin(), ::tolower);

            // Match flag name
            bool found = false;
            if (flag_name == "constant") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::constant));
                found = true;
            }
            if (flag_name == "sine") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::sine));
                found = true;
            }
            if (flag_name == "square") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::square));
                found = true;
            }
            if (flag_name == "triangle") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::triangle));
                found = true;
            }
            if (flag_name == "sawtoothup") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::sawtoothup));
                found = true;
            }
            if (flag_name == "sawtoothdown") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::sawtoothdown));
                found = true;
            }
            if (flag_name == "ramp") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::ramp));
                found = true;
            }
            if (flag_name == "spring") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::spring));
                found = true;
            }
            if (flag_name == "damper") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::damper));
                found = true;
            }
            if (flag_name == "inertia") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::inertia));
                found = true;
            }
            if (flag_name == "friction") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::friction));
                found = true;
            }
            if (flag_name == "leftright") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::leftright));
                found = true;
            }
            if (flag_name == "custom") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::custom));
                found = true;
            }
            if (flag_name == "gain") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::gain));
                found = true;
            }
            if (flag_name == "autocenter") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::autocenter));
                found = true;
            }
            if (flag_name == "status") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::status));
                found = true;
            }
            if (flag_name == "pause") {
                value = static_cast <haptic_feature>(
                    static_cast <unsigned int>(value) | static_cast <unsigned int>(haptic_feature::pause));
                found = true;
            }

            if (!found) {
                // Try to parse as integer
                try {
                    unsigned int int_value = static_cast<unsigned int>(std::stoul(flag_name));
                    value = static_cast <haptic_feature>(static_cast <unsigned int>(value) | int_value);
                } catch (...) {
                    is.setstate(std::ios::failbit);
                    return is;
                }
            }

            if (pos == std::string::npos) break;
            start = pos + 1;
        }

        return is;
    }

    std::ostream& operator<<(std::ostream& os, haptic_direction_type value) {
        switch (value) {
            case haptic_direction_type::polar:
                return os << "polar";
            case haptic_direction_type::cartesian:
                return os << "cartesian";
            case haptic_direction_type::spherical:
                return os << "spherical";
            case haptic_direction_type::steering_axis:
                return os << "steering_axis";
            default:
                return os << "Unknown_haptic_direction_type(" << static_cast <int>(value) << ")";
        }
    }

    std::istream& operator>>(std::istream& is, haptic_direction_type& value) {
        std::string str;
        is >> str;

        // Check if hex input is expected based on stream flags
        if (is.flags() & std::ios::hex) {
            try {
                unsigned int int_value = static_cast<unsigned int>(std::stoul(str, nullptr, 16));
                value = static_cast <haptic_direction_type>(int_value);
                return is;
            } catch (...) {
                is.setstate(std::ios::failbit);
                return is;
            }
        }

        // Convert to lowercase for case-insensitive comparison
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);

        if (str == "polar") {
            value = haptic_direction_type::polar;
        } else if (str == "cartesian") {
            value = haptic_direction_type::cartesian;
        } else if (str == "spherical") {
            value = haptic_direction_type::spherical;
        } else if (str == "steering_axis") {
            value = haptic_direction_type::steering_axis;
        } else {
            // Try to parse as integer
            try {
                int int_value = std::stoi(str);
                value = static_cast <haptic_direction_type>(int_value);
            } catch (...) {
                is.setstate(std::ios::failbit);
            }
        }

        return is;
    }
} // namespace
